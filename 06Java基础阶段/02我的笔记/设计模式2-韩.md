## 1、设计模式七大原则

### 1、目的

编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重 用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好

（1）代码重用性 (即：相同功能的代码，不用多次编写) 。

（2） 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 。

（3）可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 。

（4）可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)。

（5）使程序呈现高内聚，低耦合的特性。

分享金句：

 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计 （OOA/D）的精要。” Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是 前者手背上有很多伤疤。

2、七大原则

设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模 式的基础(即：设计模式为什么这样设计的依据)。

设计模式常用的七大原则有: 

 （1）单一职责原则 

（2）接口隔离原则

（3）依赖倒转(倒置)原则 

（4）里氏替换原则

（5）开闭原则

（6）迪米特法则 

（7）合成复用原则

### 2、单一职责原则 

1、基本介绍

对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 类A1，类A2。

2、细节

（1）低类的复杂度，一个类只负责一项职责。 

（2）提高类的可读性，可维护性。

（3）降低变更引起的风险。

（4）通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。

3、代码

```
com/atguigu/principle/singleresponsibility/SingleResponsibility1.java
```

### 3、接口隔离原则(Interface Segregation Principle)

1、介绍

客户端不应该依赖它不需要的接 口，即一个类对另一个类的依赖 应该建立在最小的接口上。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200921192131742.png" alt="image-20200921192131742" style="zoom:80%;" />

2、接口隔离原则

（1）类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不 需要的方法。

（2）将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

（3）接口Interface1中出现的方法，根据实际情况拆分为三个接口。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200921192309434.png" alt="image-20200921192309434" style="zoom:80%;" />



3、代码

```
com/atguigu/principle/segregation/Segregation1.java
```

### 4、依赖倒转原则（Dependence Inversion Principle）

1、介绍

（1）高层模块不应该依赖低层模块，二者都应该依赖其抽象。

（2）抽象不应该依赖细节，细节应该依赖抽象。

（3）依赖倒转(倒置)的中心思想是面向接口编程。

（4）依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的 多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象 指的是接口或抽象类，细节就是具体的实现类。

（5）使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的 任务交给他们的实现类去完成。

2、细节

（1）低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。

（2）变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化。

（3）继承时遵循里氏替换原则。

2、代码

```
com/atguigu/principle/inversion/DependecyInversion.java
```

### 5、里氏替换原则（Liskov Substitution Principle）

1、介绍

继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏。

继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子 类的功能都有可能产生故障

麻省理工学院的里女士提出的里氏替换原则(Liskov Substitution Principle)如下：

如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。

以上的里氏替换原则告诉我们，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法，同时也告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

2、代码

```
com/atguigu/principle/liskov/improve/Liskov.java
```

### 6、开闭原则（Open Closed Principle）

1、介绍

（1）一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。 

（2）当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已 有的代码来实现变化。

（3） 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

2、案例

画图形的功能。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200921202843550.png" alt="image-20200921202843550" style="zoom:67%;" />

使用开闭原则的思路：

把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可， 这样当我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可， 使用方的代码就不需要修该，即满足了开闭原则。

3、代码

```
com/atguigu/principle/ocp/Ocp.java
```

### 7、迪米特法则(Demeter Principle)

1、介绍

（1）一个对象应该对其他对象保持最少的了解。

（2）类与类关系越密切，耦合度越大。

（3）迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息。

（4）迪米特法则还有个更简单的定义：只与直接的朋友通信。

（5）直接的朋友

每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。

耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现**成员变量，方法参数，方法返回值**中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。

2、细节

（1）迪米特法则的核心是降低类之间的耦合。

（2）由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系。

3、代码

```
com/atguigu/principle/demeter/improve/Demeter1.java
```

### 8、合成复用原则（Composite Reuse Principle）

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200921210206878.png" alt="image-20200921210206878" style="zoom:80%;" />

设计原则核心思想：

（1）找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 

（2）针对接口编程，而不是针对实现编程。

（3）为了交互对象之间的松耦合设计而努力。

## 2、设计模式概述和分类

1、掌握设计模式的层次

（1）刚开始学编程不久，听说过什么是设计模式 

（2）有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但 是自己却不知道

（3）学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式 挺好用的

（4）阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够 领会设计模式的精妙和带来的好处。

（5）代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。

2、概述

（1）设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验， 模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern） 代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时 间的试验和错误总结出来的。 

（2）设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。

3、类型

（1）创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。

 （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 

（3）行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模 式、策略模式、职责链模式(责任链模式)。

## 3、适配器模式

### 1、介绍

1、概述

适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper) 。

适配器模式属于结构型模式 ，主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。

2、工作原理

从用户的角度看不到被适配者，是解耦的。用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。

用户收到反馈结果，感觉只是和目标接口交互，如图：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200922203803371.png" alt="image-20200922203803371" style="zoom:80%;" />

3、使用介绍

Adapter类，通过继承 src类（被适配者），实现 dst 类（目标类）接口，完成src->dst的适配。

### 2、案例

需求

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电 相当于src (即被适配者)，我们的目dst(即目标)是5V直流电，使用对象适配器模式完成。

1、被适配的类

```java
package com.atguigu.adapter.objectadapter;

/**
 * 对象适配器-被适配的类
 */
public class Voltage220V {
   //输出220V的电压，不变
   public int output220V() {
      int src = 220;
      System.out.println("电压=" + src + "伏");
      return src;
   }
}
```

2、适配接口

```java
package com.atguigu.adapter.objectadapter;

//适配接口
public interface IVoltage5V {
	public int output5V();
}
```

3、适配器类

```java
package com.atguigu.adapter.objectadapter;

/**
 * 持有src类的实例，以解决兼容性的问题。 即：持有 src类，实现 dst 类接口，
 * 完成src->dst的适配
 */
//适配器类 拿到220v电压，变成5V
public class VoltageAdapter implements IVoltage5V {
   //持有src类的实例
   private Voltage220V voltage220V; // 关联关系-聚合

   //通过构造器，传入一个 Voltage220V 实例
   public VoltageAdapter(Voltage220V voltage220v) {
      this.voltage220V = voltage220v;
   }

   @Override
   public int output5V() {
      int dst = 0;
      if (null != voltage220V) {
         int src = voltage220V.output220V();//获取220V 电压
         System.out.println("使用对象适配器，进行适配~~");
         dst = src / 44;
         System.out.println("适配完成，输出的电压为=" + dst);
      }
      return dst;
   }
}
```

4、目标使用类

```java
package com.atguigu.adapter.objectadapter;

public class Phone {
   //充电 适配完成后。传入一个接口，依赖被适配器类Voltage220
   public void charging(IVoltage5V iVoltage5V) {
      if(iVoltage5V.output5V() == 5) {
         System.out.println("电压为5V, 可以充电~~");
      } else if (iVoltage5V.output5V() > 5) {
         System.out.println("电压大于5V, 不能充电~~");
      }
   }
}
```

5、测试类-客户端

```java
package com.atguigu.adapter.objectadapter;

public class Client {
   public static void main(String[] args) {
      System.out.println(" === 对象适配器模式 ====");
      Phone phone = new Phone();
      //完成充电任务
      phone.charging(new VoltageAdapter(new Voltage220V()));
   }
}
```

6、细节

（1）三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来 命名的。 

（2）对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有。































