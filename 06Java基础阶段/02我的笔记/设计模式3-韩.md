## 1、模板方法模式（Template Method Pattern）

### 1、介绍

（1）概述

模板方法模式（Template Method Pattern），又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定 步骤

（2）原理图

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200923194751198.png" alt="image-20200923194751198" style="zoom:67%;" />

（1）AbstractClass抽象类：类中实现了模板方法(template)，定义了算法的骨 架，具体子类需要去实现。

（2） ConcreteClass：实现抽象方法operationr, 以完成算法中子类的步骤。

### 2、案例

1、需求

制作豆浆的流程 选材--->添加配料--->浸泡--->放到豆浆机打碎，但是这几个步骤对于制作每种口味的豆浆都是一样的。

通过添加不同的配料，可以制作出不同口味的豆浆。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200923195015214.png" alt="image-20200923195015214" style="zoom:67%;" />

2、代码

（1）抽象类

```java
//表示豆浆
public abstract class SoyaMilk {
      //模板方法, make , 模板方法可以做成final , 不让子类去覆盖.
      final void make() {
         select();
         addCondiments();
         soak();
         beat();
      }

   //选材料
   void select() {
      System.out.println("第一步：选择好的新鲜黄豆  ");
   }

   //添加不同的配料， 抽象方法, 子类具体实现
   abstract void addCondiments();

   //浸泡
   void soak() {
      System.out.println("第三步， 黄豆和配料开始浸泡， 需要3小时 ");
   }

   void beat() {
      System.out.println("第四步：黄豆和配料放到豆浆机去打碎  ");
   }
}
```

（2）子类-PeanutSoyaMilk

```java
public class PeanutSoyaMilk extends SoyaMilk {
	@Override
	void addCondiments() {
		System.out.println(" 加入上好的花生 ");
	}
}
```

（3）客户端

```java
public class Client {
   public static void main(String[] args) {
      //制作红豆豆浆
      System.out.println("----制作红豆豆浆----");
      SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
      redBeanSoyaMilk.make();
      
      System.out.println("----制作花生豆浆----");
      SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
      peanutSoyaMilk.make();
   }
}
```

### 3、钩子方法

1、介绍

在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。

做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，请使用钩子方法对前面的模板方法进行改造。

（1）抽象类改造

```java
//抽象类，表示豆浆
public abstract class SoyaMilk {

   //模板方法, make , 模板方法可以做成final , 不让子类去覆盖.
   final void make() {
      select();
      if (customerWantCondiments()) {
         addCondiments();
      }
      soak();
      beat();

   }

   //选材料
   void select() {
      System.out.println("第一步：选择好的新鲜黄豆  ");
   }

   //添加不同的配料， 抽象方法, 子类具体实现
   abstract void addCondiments();

   //浸泡
   void soak() {
      System.out.println("第三步， 黄豆和配料开始浸泡， 需要3小时 ");
   }

   void beat() {
      System.out.println("第四步：黄豆和配料放到豆浆机去打碎  ");
   }

   //钩子方法，决定是否需要添加配料
   boolean customerWantCondiments() {
      return true;
   }
}
```

（2）添加纯豆浆类

```java
//纯豆浆
public class PureSoyaMilk extends SoyaMilk {

   @Override
   void addCondiments() {
      //空实现，不叫任何调料
   }

   //钩子方法，覆盖掉父类中的方法
   @Override
   boolean customerWantCondiments() {
      return false;
   }
}
```

（3）客户端调用

```java
public class Client {
   public static void main(String[] args) {
      System.out.println("----制作花生豆浆----");
      SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
      peanutSoyaMilk.make();
      
      System.out.println("----制作纯豆浆----");
      SoyaMilk pureSoyaMilk = new PureSoyaMilk();
      pureSoyaMilk.make();
   }
}
```

### 4、细节

（1）基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算 法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改 

（2）实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接 使用。 

（3）既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不 变，同时由子类提供部分步骤的实现。 

（4）该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加， 使得系统更加庞大 

（5）一般模板方法都加上final关键字， 防止子类重写模板方法。

（6）模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这一 系列的步骤基本相同，但其个别步骤在实现时 可能不同，通常考虑用模板方法模式来处理。

## 2、命令模式（Command Pattern）

### 1、介绍

（1）概述

在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个， 我们只需在程序运行时指定具体的请求接收者即可。

命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让 对象之间的调用关系更加灵活，实现解耦。

比如：我们希望只要一个app就可以控制全部智能家电。要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给app调用，这时 就可以考虑使用命令模式。

（2）原理类图

通俗易懂的理解：将军发布命令，士兵去执行。

其中有几个角色： 将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。 

Invoker是调用者（将军），Receiver是被调用者（士兵）， MyCommand是命令，实现了Command接口，持有接收对象。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200923203818107.png" alt="image-20200923203818107" style="zoom:67%;" />

（1）Invoker：调用者角色。

（2）Command: 命令角色，需要执行的所有命令都在这里，可以是接口或抽象类。

（3）Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作。

（4）ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute。

### 2、案例

1、需求

使用命令模式 完成前面的智能家电项目

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200923204034870.png" alt="image-20200923204034870" style="zoom:80%;" />

2、代码

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20200923210926518.png" alt="image-20200923210926518" style="zoom:67%;" />

（1）创建命令接口-Command

```java
public interface Command {
   //执行动作(操作)
   public void execute();
   //撤销动作(操作)
   public void undo();
}
```

（2）创建具体执行者-ConcreteCommand

```java
public class LightOnCommand implements Command {
	//聚合LightReceiver
	LightReceiver light;

	//构造器
	public LightOnCommand(LightReceiver light) {
		super();
		this.light = light;
	}

	@Override
	public void execute() {
		//调用接收者的方法
		light.on();
	}

	@Override
	public void undo() {
		//调用接收者的方法
		light.off();
	}
}
```

```java
public class LightOffCommand implements Command {
   // 聚合LightReceiver
   LightReceiver light;

   // 构造器
   public LightOffCommand(LightReceiver light) {
      super();
      this.light = light;
   }

   @Override
   public void execute() {
      // 调用接收者的方法
      light.off();
   }

   @Override
   public void undo() {
      // 调用接收者的方法
      light.on();
   }
}
```

（3）创建接收者-Receiver

```java
public class LightReceiver {
   public void on() {
      System.out.println(" 电灯打开了.. ");
   }
   
   public void off() {
      System.out.println(" 电灯关闭了.. ");
   }
}
```

（4）创建遥控器-invoke

```java
//遥控器 一个按钮就代表一个命令
public class RemoteController {

   // 开 按钮的命令数组
   Command[] onCommands;
   Command[] offCommands;

   // 执行撤销的命令
   Command undoCommand;

   // 构造器，完成对按钮初始化
   public RemoteController() {
      onCommands = new Command[5];
      offCommands = new Command[5];

      //遥控器上有五排按钮
      for (int i = 0; i < 5; i++) {
         //使用到了空命令
         onCommands[i] = new NoCommand();
         offCommands[i] = new NoCommand();
      }
   }

   // 给我们的按钮设置你需要的命令
   public void setCommand(int no, Command onCommand, Command offCommand) {
      onCommands[no] = onCommand;
      offCommands[no] = offCommand;
   }

   // 按下开按钮
   public void onButtonWasPushed(int no) { // no 0
      // 找到你按下的开的按钮， 并调用对应方法
      onCommands[no].execute();
      // 记录这次的操作，用于撤销
      undoCommand = onCommands[no];
   }

   // 按下开按钮
   public void offButtonWasPushed(int no) { // no 0
      // 找到你按下的关的按钮， 并调用对应方法
      offCommands[no].execute();
      // 记录这次的操作，用于撤销
      undoCommand = offCommands[no];
   }

   // 按下撤销按钮
   public void undoButtonWasPushed() {
      undoCommand.undo();
   }
}
```

（5）客户端测试

```java
public class Client {
   public static void main(String[] args) {
      //使用命令设计模式，完成通过遥控器，对电灯的操作

      //创建电灯的对象(接受者)
      LightReceiver lightReceiver = new LightReceiver();

      //创建电灯相关的开关命令
      LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
      LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);

      //需要一个遥控器
      RemoteController remoteController = new RemoteController();

      //给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作
      remoteController.setCommand(0, lightOnCommand, lightOffCommand);

      System.out.println("--------按下灯的开按钮-----------");
      remoteController.onButtonWasPushed(0);
      System.out.println("--------按下灯的关按钮-----------");
      remoteController.offButtonWasPushed(0);
      System.out.println("--------按下撤销按钮-----------");
      remoteController.undoButtonWasPushed();
   }
}
```

### 3、细节

1、将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要 调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对 象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：” 请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到 了纽带桥梁的作用。

2、容易实现对请求的撤销和重做。

3、空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。

4、缺点：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这 点在在使用的时候要注意。































