# 1、查询

## 1、递归树形结构获取数据

1、CategoryController书写分类方法

```java
/**
	 * 查出所有分类以及子分类，以树形结构组装起来
	 */
	@RequestMapping("/list/tree")
	public R list() {
		List<CategoryEntity> categoryEntities = categoryService.listWithTree();
		//找到所有的一级分类
		return R.ok().put("data", categoryEntities);
	}
```

在对应的接口实现类CategoryServiceImpl中书写核心递归方法：

通过分类的parent_cid来进行判断，如果是一级分类，其值为0。

```java
@Override
	public List<CategoryEntity> listWithTree() {
		//1、发送一个sql语句查出所有菜单/分类
		List<CategoryEntity> entities = baseMapper.selectList(null);
		//2、组装成父子的树形结构
		//找到所有的一级分类
		List<CategoryEntity> level1Menu = entities.stream().filter(categoryEntity ->
				categoryEntity.getParentCid() == 0
		).map((menu) -> {
			//将当前菜单的子分类保存进去
			menu.setChildren(getChildrens(menu, entities));
			//并将当前菜单返回
			return menu;
		}).sorted((menu1, menu2) -> {
			return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
		}).collect(Collectors.toList());
		return level1Menu;
	}

	/**
	 * 从all中递归查找当前菜单root的子菜单
	 *
	 * @param root 当前菜单
	 * @param all  所有菜单
	 * @return
	 */
	public List<CategoryEntity> getChildrens(CategoryEntity root, List<CategoryEntity> all) {

		List<CategoryEntity> childrens = all.stream().filter(item -> {
			return item.getParentCid() == root.getCatId();
		}).map(item -> {
			//1、找到子菜单，对子菜单再一次进行递归
			item.setChildren(getChildrens(item, all));
			return item;
		}).sorted((menu1, menu2) -> {
			//2、菜单的升序排列
			return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
		}).collect(Collectors.toList());
		return childrens;
	}
```

2、renren-fast的pom文件中添加common依赖

```xml
<dependency>
  <groupId>com.xiaolun.gulimall</groupId>
  <artifactId>gulimall-common</artifactId>
  <version>0.0.1-SNAPSHOT</version>
</dependency>
```

## 2、配置网关路由与路径重写

1、配置nacos

为了能够让gateway路由到指定的地址，在gulimall-product和renren-fast中都需要配置nacos，添加上bootstrap.properties文件以及在主启动类中添加开启发现。

```properties
spring.application.name=gulimall-gateway
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
```

为了配置分离，在nacos中创建product命名空间：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110124345397.png" alt="image-20210110124345397" style="zoom:67%;" />

2、添加商品系统界面

（1）添加商品系统和分类维护

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110111247397.png" alt="image-20210110111247397" style="zoom: 50%;" />

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110111433084.png" alt="image-20210110111433084" style="zoom:67%;" />

创建上面的目录或菜单后，在数据库中都有相应的显示：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110124750603.png" alt="image-20210110124750603" style="zoom:67%;" />

根据分类维护的菜单路由结合Vscode代码，我们需要创建下面的category.vue模块。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110111632575.png" alt="image-20210110111632575" style="zoom:67%;" />

3、将前端页面的访问路径变成访问网关路径

（1）修改index.js中的url路径

```js
// api接口请求地址
// 将 http://localhost:8080/renren-fast 地址转化为 http://localhost:88(/也去掉，拼接时会加上/)，此时只给网关发请求
window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
```

（2）书写category.vue网页结构

```vue
<template>
<!--添加树形结构-->
  <el-tree
    :data="menus"
    :props="defaultProps"
    @node-click="handleNodeClick"
  ></el-tree>
</template>


<script>
export default {
  data() {
    return {
      menus: [],
      defaultProps: {
        children: "children",
        label: "name", // 作为标签的值进行展示
      },
    };
  },
  methods: {
    handleNodeClick(data) {
      console.log(data);
    },
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
        //发送成功之后的函数，{data}表示将发送成功的内容data属性解构出来
      }).then(({data}) => {
        console.log("成功获取到data.data菜单数据-------", data.data);
        this.menus = data.data
      });
    },
  },

  //生命周期-创建完成（可以访问当前的this实例）
  created() {
    this.getMenus();
  },
};
</script>
```

假如代码中的then(({data})使用then((data) ，此时返回的数据中包含请求头等信息，并不是我们想要的。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110122412978.png" alt="image-20210110122412978" style="zoom:67%;" />

   `data.data`的第2个data需要和controller中的对应，是返回来的key值。

4、gateway模块中配置路由重写

```yaml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848 # nacos server注册中心地址
    gateway:
      routes: 
        # 对商品服务设置路由规则(路径精确的放上面)
        - id: product_route
          uri: lb://gulimall-product
          predicates:
            - Path=/api/product/**
          filters:
            - RewritePath=/api/(?<segment>/?.*),/$\{segment}

        # 对登录服务设置路由规则
        - id: admin_route
          uri: lb://renren-fast
          predicates:
            - Path=/api/**
          filters: # 路径重写
            - RewritePath=/api/(?<segment>/?.*), /renren-fast/$\{segment}
```

网关配置依据如下：
<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110124451385.png" alt="image-20210110124451385" style="zoom:67%;" />

上文配置的路由规则对应下面两种情况：

（1）对商品服务配置路由

配置之后，可以将请求正确的转发：

```http
# 原来路由
http://localhost:8080/renren-fast/product/category/list/tree
# 配置网关和index.js之后路由
http://localhost:10000/product/category/list/tree
```

（2）对登录服务配置路由

```http
# 现在的验证码请求路径为，http://localhost:88/api/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6
# 原始的验证码请求路径：
http://localhost:8001/renren-fast/captcha.jpg?uuid=69c79f02-d15b-478a-8465-a07fd09001e6
```

登录服务配置成功后，验证码可以正常加载，但是访问被拒绝了，此时需要配置跨域请求。

## 3、跨域请求

1、介绍

参考网址：

```http
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS
```

（1）概述

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。

同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域。

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110123243809.png" alt="image-20210110123243809" style="zoom:67%;" />

（2）跨域流程

![image-20210110123337424](https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110123337424.png)

（3）解决跨域

+ 使用nginx部署为同一域

![image-20210110123445545](https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210110123445545.png)

+ 配置当次请求允许跨域

```
添加响应头：
Access-Control-Allow-Origin：支持哪些来源的请求跨域
Access-Control-Allow-Methods：支持哪些方法跨域
Access-Control-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含cookie
Access-Control-Expose-Headers：跨域请求暴露的字段
CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
Access-Control-Max-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。
```

2、在gateway模块中解决跨域请求

```java
package com.xiaolun.gulimall.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

/**
 * @time: 2021-01-10 09:54
 * @author: likunlun
 * @description: 解决跨域请求
 */
@Configuration
public class GulimallCorsConfiguration {
	@Bean
	public CorsWebFilter corsWebFilter() {
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		CorsConfiguration corsConfiguration = new CorsConfiguration();
		corsConfiguration.addAllowedHeader("*");
		corsConfiguration.addAllowedMethod("*");
		corsConfiguration.addAllowedOrigin("*");
		corsConfiguration.setAllowCredentials(true);
		source.registerCorsConfiguration("/**", corsConfiguration);
		return new CorsWebFilter(source);
	}
}
```

由于在gateway模块中统一配置了跨域请求，因此，将renren-fast中配置的跨域请求给注释掉即可。

# 2、删除/新增

## 1、修改CategoryController中的删除操作

```java
	/**
	 * 删除
	 *
	 * @RequestBody:获取请求体，必须使用post请求发送； springmvc自动将请求体的数据（json）转化为对应的对象。
	 */
	@RequestMapping("/delete")
	public R delete(@RequestBody Long[] catIds) {
		//1、检查当前删除的菜单，是否被别的地方引用
//		categoryService.removeByIds(Arrays.asList(catIds));
		categoryService.removeMenuByIds(Arrays.asList(catIds));
		return R.ok();
	}
```

实现类：

```java
	@Override
	public void removeMenuByIds(List<Long> asList) {
		//TODO 1、检查当前删除的菜单，是否被别的地方引用
		baseMapper.deleteBatchIds(asList);
	}
```

## 2、页面效果

```vue
<template>
  <div>
    <!--添加树形结构
  :default-expanded-keys="expandedkeys" 动态绑定一个数据(前头有一个冒号数据)
  :expand-on-click-node="false" 设置节点点击时不展开
  -->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
    >
      <!-- 插槽形式，解构写法，node当前节点，data节点数据 -->
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <!-- 添加两个按钮 -->
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!-- 添加一个对话框 -->
    <el-dialog title="提示" :visible.sync="dialogVisible" width="30%">
      <!-- dialog中添加一个嵌套表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="addCategory">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>


<script>
export default {
  data() {
    return {
      category: { name: "", parentCid: 0, showStatus: 1, catLevel: 0, sort: 0 }, //表单绑定的数据
      menus: [],
      dialogVisible: false, //默认对话框关闭
      expandedKey: [], //默认为null，没有什么要展开的。删除成功时要展开，不要合并上。
      defaultProps: {
        children: "children",
        label: "name", // 作为标签的值进行展示
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
        //发送成功之后的函数，{data}表示将发送成功的内容data属性解构出来
      }).then(({ data }) => {
        console.log("成功获取到data.data菜单数据-------", data.data);
        this.menus = data.data;
      });
    },
    // 书写箭头函数@click="() => append(data)对应的方法
    append(data) {
      console.log("append", data);
      //打开对话框，添加元素
      this.dialogVisible = true;
      this.category.parentCid = data.catId;
      // 新增的层级= 当前层级（字符串）*1 + 1
      this.category.catLevel = data.catLevel * 1 + 1;
    },

    remove(node, data) {
      console.log("remove", node, data);
      var ids = [data.catId];
      //删除数据之前，首先弹框提示( ${data.name} 外面有一个飘号)
      this.$confirm(`是否删除【 ${data.name} 】菜单?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            //删除成功，消息提示
            this.$message({
              message: "菜单删除成功",
              type: "success",
            });
            // 删除成功之后，重新刷新出菜单
            this.getMenus();
            //设置需要默认展开的菜单,赋值为删除节点的父节点id
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },
    //添加三级分类的方法
    //this.category 是已经构造好的数据对象
    addCategory() {
      console.log("向服务器提交的三级分类数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单保存成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
         this.expandedKey = [this.category.parentCid];
      });
    },
  },

  //生命周期-创建完成（可以访问当前的this实例）
  created() {
    this.getMenus();
  },
};
</script>
```

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111094300550.png" alt="image-20210111094300550" style="zoom:67%;" />

## 3、使用postman进行真实删除

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111094407914.png" alt="image-20210111094407914" style="zoom:67%;" />

在数据库的pms_category中catId=501的数据被删除。

## 4、逻辑删除

（1）application.yml文件中添加全局删除规则

```yaml
mybatis-plus:
  mapper-locations: classpath:/mapper/**/*.xml
  global-config:
    db-config:
      id-type: auto # 用来对Entity包下的所有实体类进行自增主键
      logic-delete-value: 1 # 代表逻辑已删除  # @TableLogic(value = "1",delval = "0")优先级大于本文件
      logic-not-delete-value: 0 # 代表逻辑未删除
```

3.1.0之后不需要注册bean。

（2）在CategoryEntity中添加注解

```java
	/**
	 * 是否显示[0-不显示（删除），1显示(不删除)]
	 * 添加逻辑删除注解，逻辑删除就是0
	 */
	@TableLogic(value = "1",delval = "0")
	private Integer showStatus;
```

这里的注解可以理解为一种局部注解，和全局配置相反。

（3）application.yml文件中修改日志级别，查看删除语句

```yaml
# 用来查看逻辑删除的sql语句
logging:
  level:
    com.xiaolun.gulimall.product: debug
```

当我们使用postman进行删除时，数据库数据仍旧存在，显示状态变成0。控制台的删除语句变成了更新语句。

# 3、修改

## 1、关闭前端中严格的语法检查

```js
// 关闭eslint严格语法检查，将下面代码注释
//路径： vue\build\webpack.base.conf.js
const createLintingRule = () => ({
})
```

## 2、基本修改

```vue
<template>
  <div>
    <!--添加树形结构
  :default-expanded-keys="expandedkeys" 动态绑定一个数据(前头有一个冒号数据)
  :expand-on-click-node="false" 设置节点点击时不展开
  -->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
    >
      <!-- 插槽形式，解构写法，node当前节点，data节点数据 -->
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <!-- 添加两个按钮 -->
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button type="text" size="mini" @click="() => edit(data)">
            Edit
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!-- 添加一个对话框 
    :close-on-click-modal="false"表示通过点击 modal（弹出对话框的叉号） 来关闭 Dialog
    -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- dialog中添加一个嵌套表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>


<script>
export default {
  data() {
    return {
      title: "", //对话框提示的动态绑定
      dialogType: "", //为对话框的复用（添加add/修改edit）操作做准备,规定了两个类型
      category: {
        name: "",
        parentCid: 0,
        showStatus: 1,
        catLevel: 0,
        sort: 0,
        catId: null,
        productUnit: null,
        icon: "",
      }, //表单绑定的数据
      menus: [],
      dialogVisible: false, //默认对话框关闭
      expandedKey: [], //默认为null，没有什么要展开的。删除成功时要展开，不要合并上。
      defaultProps: {
        children: "children",
        label: "name", // 作为标签的值进行展示
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
        //发送成功之后的函数，{data}表示将发送成功的内容data属性解构出来
      }).then(({ data }) => {
        console.log("成功获取到data.data菜单数据-------", data.data);
        this.menus = data.data;
      });
    },
    // 书写箭头函数@click="() => append(data)对应的方法
    append(data) {
      console.log("append", data);
      this.dialogType = "add"; //对话框变成添加类型
      this.title = "添加分类";
      //打开对话框，添加元素
      this.dialogVisible = true;
      this.category.parentCid = data.catId;
      // 新增的层级= 当前层级（字符串）*1 + 1
      this.category.catLevel = data.catLevel * 1 + 1;
      //清空表格中回显的值
      this.category.catId = null; //不带id的添加，id自增
      this.category.name = "";
      this.category.icon = "";
      this.category.productUnit = "";
      this.category.sort = 0;
      this.category.showStatus = 1;
    },
    //data:当前节点的数据
    edit(data) {
      console.log("edit", data);
      this.dialogType = "edit"; //对话框变成修改类型
      this.title = "修改分类";
      //用于点击edit标签进行回显操作
      this.dialogVisible = true;

      /*
        1、当其他人使用同一个系统，已经修改了数据，而我使用的还是10分钟
        前刷新出来的数据。正确回显方式应该是发送请求获取当前节点最新的数据，
        之后我们再进行修改。
         this.category.name = data.name;
        //catId用于后端进行更新操作
        this.category.catId = data.catId;
        2、${data.catId}动态获取id信息
      */
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: "get",
      }).then(({ data }) => {
        //请求成功之后，将服务器中的数据进行回显。
        console.log("要回显的数据", data);
        this.category.catId = data.data.catId;
        this.category.name = data.data.name;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        this.category.parentCid = data.data.parentCid;
      });
    },

    remove(node, data) {
      console.log("remove", node, data);
      var ids = [data.catId];
      //删除数据之前，首先弹框提示( ${data.name} 外面有一个飘号)
      this.$confirm(`是否删除【 ${data.name} 】菜单?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            //删除成功，消息提示
            this.$message({
              message: "菜单删除成功",
              type: "success",
            });
            // 删除成功之后，重新刷新出菜单
            this.getMenus();
            //设置需要默认展开的菜单,赋值为删除节点的父节点id
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },
    //判断对话框的操作是添加请求还是修改请求
    submitData() {
      if (this.dialogType == "add") {
        this.addCategory();
      }
      if (this.dialogType == "edit") {
        this.editCategory();
      }
    },
    //修改三级分类
    editCategory() {
      // 将要发送给前端的数据解构出来，不是全部发送
      var { catId, name, icon, productUnit } = this.category;
      var data = {
        catId: catId,
        name: name,
        icon: icon,
        productUnit: productUnit,
      };
      this.$http({
        url: this.$http.adornUrl("/product/category/update"),
        method: "post",
        data: this.$http.adornData(data, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单修改成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
    //添加三级分类的方法
    //this.category 是已经构造好的数据对象
    addCategory() {
      console.log("向服务器提交的三级分类数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单保存成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
  },

  //生命周期-创建完成（可以访问当前的this实例）
  created() {
    this.getMenus();
  },
};

```

添加分类的界面：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111134926134.png" alt="image-20210111134926134" style="zoom: 50%;" />

在 append(data) {}函数中会清空回显的值，因此在添加对话框界面打开后是一个空白。

修改分类的界面：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111134957192.png" alt="image-20210111134957192" style="zoom:67%;" />

点击确定之后，修改分类对应的树会展开。

## 3、拖拽效果

### 1、基本拖拽

前端代码

```vue
<template>
  <div>
    <!--添加树形结构
  :default-expanded-keys="expandedkeys" 动态绑定一个数据(前头有一个冒号数据)
  :expand-on-click-node="false" 设置节点点击时不展开
  draggable 开启拖拽效果
  allow-drop 拖拽时判定目标节点能否被放置
  @node-drop="handleDrop" 表示拖拽成功对应的事件
  -->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      draggable
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
    >
      <!-- 插槽形式，解构写法，node当前节点，data节点数据 -->
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <!-- 添加两个按钮 -->
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button type="text" size="mini" @click="() => edit(data)">
            Edit
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!-- 添加一个对话框 
    :close-on-click-modal="false"表示通过点击 modal（弹出对话框的叉号） 来关闭 Dialog
    -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- dialog中添加一个嵌套表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>


<script>
export default {
  data() {
    return {
      updateNode: [], //排序时要修改的对象
      maxLevel: 0, //最大深度层级
      title: "", //对话框提示的动态绑定
      dialogType: "", //为对话框的复用（添加add/修改edit）操作做准备,规定了两个类型
      category: {
        name: "",
        parentCid: 0,
        showStatus: 1,
        catLevel: 0,
        sort: 0,
        catId: null,
        productUnit: null,
        icon: "",
      }, //表单绑定的数据
      menus: [],
      dialogVisible: false, //默认对话框关闭
      expandedKey: [], //默认为null，没有什么要展开的。删除成功时要展开，不要合并上。
      defaultProps: {
        children: "children",
        label: "name", // 作为标签的值进行展示
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
        //发送成功之后的函数，{data}表示将发送成功的内容data属性解构出来
      }).then(({ data }) => {
        console.log("成功获取到data.data菜单数据-------", data.data);
        this.menus = data.data;
      });
    },
    //拖拽功能的放置
    allowDrop(draggingNode, dropNode, type) {
      //判断被拖动的当前节点以及所在的父节点总层数<3
      //(1)被拖动的当前节点的总层数
      console.log(draggingNode, dropNode, type);
      // 统计当前节点的总层数
      this.countNodeLevel(draggingNode.data);
      //当前正在拖动的节点（包含子节点）所在的深度 + 父节点所在深度 <= 3即可。
      //当前拖动节点和子节点一起构成的深度
      let deep = Math.abs(this.maxLevel - draggingNode.data.catLevel) + 1;
      // console.log(
      //   `this.maxLevel:${this.maxLevel};draggingNode.data.catLevel:${draggingNode.data.catLevel};dropNode.level:${dropNode.level}`
      // );
      // console.log("深度：", deep);
      // console.log("type", type);
      if (type == "inner") {
        //<= 3表示可以返回false,表示可以拖动
        return deep + dropNode.level <= 3;
      } else {
        console.log(
          "deep + dropNode.parent.level",
          deep + dropNode.parent.level
        );
        return deep + dropNode.parent.level <= 3;
      }
    },
    //拖拽成功对应的事件
    handleDrop(draggingNode, dropNode, dropType, ev) {
      console.log("tree drop: ", draggingNode, dropNode, dropType);
      let pCid = 0;
      //排序-将拖拽节点的兄弟保存到siblings中
      let siblings = null;
      //1、当前节点最新的父节点ID（可以从dropNode参数中获取到）
      // 以兄弟方式进入时
      if (dropType == "before" || dropType == "after") {
        //当把元素拖拽到首元位置时，会出现父id=undefined的情况，对应父id为0的情况。这是一种特殊情况
        pCid =
          dropNode.parent.data.catId == undefined
            ? 0
            : dropNode.parent.data.catId;
        siblings = dropNode.parent.childNodes;
      } else {
        //当前node的id
        pCid = dropNode.data.catId;
        siblings = dropNode.childNodes;
        console.log("以inner方式进入,查看兄弟节点", siblings);
      }
      //2、当前拖拽节点的最新排序
      for (let i = 0; i < siblings.length; i++) {
        if (siblings[i].data.catId == draggingNode.data.catId) {
          //如果遍历的是当前正在拖拽的节点，不但改顺序，还要改父id。
          //如果遍历的层级发生变化(拖拽后层级和原来层级作比较)
          let catLevel = draggingNode.level;

          if (siblings[i].level != draggingNode.level) {
            //siblings[i].level:2;  draggingNode.level:1
            console.log("当前层级的变换情况：");
            console.log(
              `siblings[i].level:${siblings[i].level};draggingNode.level:${draggingNode.level}`
            );
            // if (dropType == "before" || dropType == "after") {
            //   catLevel = dropNode.catLevel;
            // } else {
            //   catLevel = dropNode.catLevel + 1;
            // }
            catLevel = siblings[i].level;
            //如果当前节点层级变化，该节点对应的子节点的层级也会发生变化。需要递归修改。
            // 将子节点的id和catId放到数组中
            this.updateChildNodeLevel(siblings[i]);
          }
          //将当前遍历节点的层级和父id放到数组中
          this.updateNode.push({
            catId: siblings[i].data.catId,
            sort: i,
            parentCid: pCid,
            catLevel: catLevel,
          });
        } else {
          //将要修改的数据封装成一个对象放到数组中
          //兄弟元素只改顺序
          this.updateNode.push({ catId: siblings[i].data.catId, sort: i });
        }
      }

      //3、当前拖拽节点的最新层级
      console.log("this.updateNode", this.updateNode);
      this.$http({
        url: this.$http.adornUrl("/product/category/update/sort"),
        method: "post",
        data: this.$http.adornData(this.updateNode, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单修改成功",
          type: "success",
        });
        //修改成功刷新菜单
        this.getMenus();
        // 拖拽菜单父级展开
        this.expandedKey = [pCid];
        //拖拽成功后将下面的数据清空为原始的默认值
        this.updateNode = [];
        this.maxLevel = 0;
      });
    },
    //改变子节点层级的方法,参数为当前节点
    updateChildNodeLevel(node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data;
          // 同步更新子节点的层级（node.childNodes[i] 写成了 cNode，导致子节点无法更新）
          this.updateNode.push({ catId: cNode.catId, catLevel: node.childNodes[i].level });
          this.updateChildNodeLevel(node.childNodes[i]);
        }
      }
    },
    countNodeLevel(node) {
      //找到所有子节点，求出最大深度
      if (node.children != null && node.children.length > 0) {
        // 说明有子节点，进行遍历
        for (let i = 0; i < node.children.length; i++) {
          if (node.children[i].catLevel > this.maxLevel) {
            this.maxLevel = node.children[i].catLevel;
          }
          //统计当前节点是不是还有子节点，使用递归调用(使用this方法)
          this.countNodeLevel(node.children[i]);
        }
      } else {
        //如果没有子节点，赋值给当前层级数,这样的话，才可以第三层级移动
        this.maxLevel = node.catLevel;
      }
    },
    // 书写箭头函数@click="() => append(data)对应的方法
    append(data) {
      console.log("append", data);
      this.dialogType = "add"; //对话框变成添加类型
      this.title = "添加分类";
      //打开对话框，添加元素
      this.dialogVisible = true;
      this.category.parentCid = data.catId;
      // 新增的层级= 当前层级（字符串）*1 + 1
      this.category.catLevel = data.catLevel * 1 + 1;
      //清空表格中回显的值
      this.category.catId = null; //不带id的添加，id自增
      this.category.name = "";
      this.category.icon = "";
      this.category.productUnit = "";
      this.category.sort = 0;
      this.category.showStatus = 1;
    },
    //data:当前节点的数据
    edit(data) {
      console.log("edit", data);
      this.dialogType = "edit"; //对话框变成修改类型
      this.title = "修改分类";
      //用于点击edit标签进行回显操作
      this.dialogVisible = true;

      /*
        1、当其他人使用同一个系统，已经修改了数据，而我使用的还是10分钟
        前刷新出来的数据。正确回显方式应该是发送请求获取当前节点最新的数据，
        之后我们再进行修改。
         this.category.name = data.name;
        //catId用于后端进行更新操作
        this.category.catId = data.catId;
        2、${data.catId}动态获取id信息
      */
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: "get",
      }).then(({ data }) => {
        //请求成功之后，将服务器中的数据进行回显。
        console.log("要回显的数据", data);
        this.category.catId = data.data.catId;
        this.category.name = data.data.name;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        this.category.parentCid = data.data.parentCid;
      });
    },

    remove(node, data) {
      console.log("remove", node, data);
      var ids = [data.catId];
      //删除数据之前，首先弹框提示( ${data.name} 外面有一个飘号)
      this.$confirm(`是否删除【 ${data.name} 】菜单?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            //删除成功，消息提示
            this.$message({
              message: "菜单删除成功",
              type: "success",
            });
            // 删除成功之后，重新刷新出菜单
            this.getMenus();
            //设置需要默认展开的菜单,赋值为删除节点的父节点id
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },

    //判断对话框的操作是添加请求还是修改请求
    submitData() {
      if (this.dialogType == "add") {
        this.addCategory();
      }
      if (this.dialogType == "edit") {
        this.editCategory();
      }
    },
    //修改三级分类
    editCategory() {
      // 将要发送给前端的数据解构出来，不是全部发送
      var { catId, name, icon, productUnit } = this.category;
      var data = {
        catId: catId,
        name: name,
        icon: icon,
        productUnit: productUnit,
      };
      this.$http({
        url: this.$http.adornUrl("/product/category/update"),
        method: "post",
        data: this.$http.adornData(data, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单修改成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
    //添加三级分类的方法
    //this.category 是已经构造好的数据对象
    addCategory() {
      console.log("向服务器提交的三级分类数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单保存成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
  },

  //生命周期-创建完成（可以访问当前的this实例）
  created() {
    this.getMenus();
  },
};
</script>
```

（1）将只有两层的一级菜单“整车”拖到一级“生鲜”目录下对应的界面变化

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111221009892.png" alt="image-20210111221009892" style="zoom:67%;" />

调试界面数据变化：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111221415220.png" alt="image-20210111221415220" style="zoom:67%;" />

数据库数据变化：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111221609763.png" alt="image-20210111221609763" style="zoom:67%;" />

（2）判断节点能够拖动的理解

前提是要保证只能有三级菜单，因此，正在拖动的节点（包含子节点）所在的深度 + 父节点所在深度 <= 3即可。

最大深度`maxLevel`的计算如下：

当某一个节点没有子节点的时候，令节点最大深度`maxLevel`为该节点层级；反之，对该节点进行遍历，找出最深的层数即为最大深度。

拖动节点深度`deep`的计算如下：

最大深度和当前拖动节点一起构成的深度层级：

```vue
let deep = Math.abs(this.maxLevel - draggingNode.data.catLevel) + 1;
```

在此基础上，对节点能否拖拽进行判断：

情况1：如果拖到某一个节点的内部：

dropNode.level 表示正在拖拽的节点进入某个父节点所在深度，deep表示拖拽节点包含层级深度。

```vue
 return deep + dropNode.level <= 3;
```

情况2：如果拖到某一个节点的前后：

dropNode.parent.level表示正在拖拽的节点进入某个父节点所在深度。

```vue
return deep + dropNode.parent.level <= 3;
```

（3）后端批量修改代码：

```java
/**
	 * 批量(动态)修改来自前端的数据
	 * 拖拽功能发来的数据
	 */
@RequestMapping("/update/sort")
public R updateSort(@RequestBody CategoryEntity[] category) {
  categoryService.updateBatchById(Arrays.asList(category));
  return R.ok();
}
```

（4）postman发送测试批量修改数据请求

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111223819334.png" alt="image-20210111223819334" style="zoom:80%;" />

### 2、批量拖拽

前端代码

```vue
<template>
  <div>
    <!--添加拖拽开关-->
    <el-switch
      v-model="draggable"
      active-text="开启拖拽"
      inactive-text="关闭拖拽"
    >
    </el-switch>
    <!--  
      v-if="draggable"(true)表示可以拖拽，按钮就会显示
    -->
    <el-button v-if="draggable" @click="batchSave">批量保存</el-button>
    <!--添加树形结构
  :default-expanded-keys="expandedkeys" 动态绑定一个数据(前头有一个冒号数据)
  :expand-on-click-node="false" 设置节点点击时不展开
  draggable 开启拖拽效果
  allow-drop 拖拽时判定目标节点能否被放置
  @node-drop="handleDrop" 表示拖拽成功对应的事件
  -->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
    >
      <!-- 插槽形式，解构写法，node当前节点，data节点数据 -->
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <!-- 添加两个按钮 -->
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button type="text" size="mini" @click="() => edit(data)">
            Edit
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!-- 添加一个对话框 
    :close-on-click-modal="false"表示通过点击 modal（弹出对话框的叉号） 来关闭 Dialog
    -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- dialog中添加一个嵌套表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>


<script>
export default {
  data() {
    return {
      pCid: [], //变成一个数组，用于批量提交后显示层级
      draggable: false, // 默认不可以拖拽树控件（和拖拽按钮进行绑定）
      updateNode: [], //排序时要修改的对象
      maxLevel: 0, //最大深度层级
      title: "", //对话框提示的动态绑定
      dialogType: "", //为对话框的复用（添加add/修改edit）操作做准备,规定了两个类型
      category: {
        name: "",
        parentCid: 0,
        showStatus: 1,
        catLevel: 0,
        sort: 0,
        catId: null,
        productUnit: null,
        icon: "",
      }, //表单绑定的数据
      menus: [],
      dialogVisible: false, //默认对话框关闭
      expandedKey: [], //默认为null，没有什么要展开的。删除成功时要展开，不要合并上。
      defaultProps: {
        children: "children",
        label: "name", // 作为标签的值进行展示
      },
    };
  },
  methods: {
    getMenus() {
      this.$http({
        url: this.$http.adornUrl("/product/category/list/tree"),
        method: "get",
        //发送成功之后的函数，{data}表示将发送成功的内容data属性解构出来
      }).then(({ data }) => {
        console.log("成功获取到data.data菜单数据-------", data.data);
        this.menus = data.data;
      });
    },
    //批量保存提交的数据
    batchSave() {
      //对应下文中的第3步,当前拖拽节点的最新层级
      //将拖拽后的表单数据发送到数据库
      console.log("this.updateNode", this.updateNode);
      this.$http({
        url: this.$http.adornUrl("/product/category/update/sort"),
        method: "post",
        data: this.$http.adornData(this.updateNode, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单修改成功",
          type: "success",
        });
        //修改成功刷新菜单
        this.getMenus();
        // 拖拽菜单父级展开（展开的是一个数组）
        this.expandedKey = this.pCid;
        //拖拽成功后将下面的数据清空为原始的默认值
        this.updateNode = [];
        this.maxLevel = 0;
        // this.pCid = 0;
      });
    },
    //拖拽功能的放置
    allowDrop(draggingNode, dropNode, type) {
      //判断被拖动的当前节点以及所在的父节点总层数<3
      //(1)被拖动的当前节点的总层数
      console.log(draggingNode, dropNode, type);
      // 统计当前节点的总层数
      this.countNodeLevel(draggingNode);
      //当前正在拖动的节点（包含子节点）所在的深度 + 父节点所在深度 <= 3即可。
      //当前拖动节点和子节点一起构成的深度
      //由于使用到了批量删除，应该使用树本身的level来判断能够被拖拽，因此，数据还没有
      // 提交，获取到的draggingNode.data.level的层级没有实时改变。
      let deep = Math.abs(this.maxLevel - draggingNode.level) + 1;
      if (type == "inner") {
        //<= 3表示可以返回false,表示可以拖动
        return deep + dropNode.level <= 3;
      } else {
        return deep + dropNode.parent.level <= 3;
      }
    },
    //拖拽成功对应的事件
    handleDrop(draggingNode, dropNode, dropType, ev) {
      console.log("tree drop: ", draggingNode, dropNode, dropType);
      let pCid = 0;
      //排序-将拖拽节点的兄弟保存到siblings中
      let siblings = null;
      //1、当前节点最新的父节点ID（可以从dropNode参数中获取到）
      // 以兄弟方式进入时
      if (dropType == "before" || dropType == "after") {
        //当把元素拖拽到首元位置时，会出现父id=undefined的情况，对应父id为0的情况。这是一种特殊情况
        pCid =
          dropNode.parent.data.catId == undefined
            ? 0
            : dropNode.parent.data.catId;
        siblings = dropNode.parent.childNodes;
      } else {
        //当前node的id
        pCid = dropNode.data.catId;
        siblings = dropNode.childNodes;
      }
      // 全局pCid,为了批量保存后能够展开
      this.pCid.push(pCid);
      //2、当前拖拽节点的最新排序
      for (let i = 0; i < siblings.length; i++) {
        if (siblings[i].data.catId == draggingNode.data.catId) {
          //如果遍历的是当前正在拖拽的节点，不但改顺序，还要改父id。
          //如果遍历的层级发生变化(拖拽后层级和原来层级作比较)
          let catLevel = draggingNode.level;

          if (siblings[i].level != draggingNode.level) {
            //siblings[i].level:2;  draggingNode.level:1
            console.log("当前层级的变换情况：");
            console.log(
              `siblings[i].level:${siblings[i].level};draggingNode.level:${draggingNode.level}`
            );

            catLevel = siblings[i].level;
            //如果当前节点层级变化，该节点对应的子节点的层级也会发生变化。需要递归修改。
            // 将子节点的id和catId放到数组中
            this.updateChildNodeLevel(siblings[i]);
          }
          //将当前遍历节点的层级和父id放到数组中
          this.updateNode.push({
            catId: siblings[i].data.catId,
            sort: i,
            parentCid: pCid,
            catLevel: catLevel,
          });
        } else {
          //将要修改的数据封装成一个对象放到数组中
          //兄弟元素只改顺序
          this.updateNode.push({ catId: siblings[i].data.catId, sort: i });
        }
      }

      //3、当前拖拽节点的最新层级,将拖拽后的表单数据发送到数据库
      // console.log("this.updateNode", this.updateNode);
    },

    //改变子节点层级的方法,参数为当前节点
    updateChildNodeLevel(node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data;
          // 同步更新子节点的层级（node.childNodes[i] 写成了 cNode，导致子节点无法更新）
          this.updateNode.push({
            catId: cNode.catId,
            catLevel: node.childNodes[i].level,
          });
          this.updateChildNodeLevel(node.childNodes[i]);
        }
      }
    },
    countNodeLevel(node) {
      //找到所有子节点，求出最大深度
      // 由于使用到了批量保存，使用树本身的层级结构，更改node.children
      if (node.childNodes != null && node.childNodes.length > 0) {
        // 说明有子节点，进行遍历
        for (let i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].level > this.maxLevel) {
            this.maxLevel = node.childNodes[i].level;
          }
          //统计当前节点是不是还有子节点，使用递归调用(使用this方法)
          this.countNodeLevel(node.childNodes[i]);
        }
      } else {
        //如果没有子节点，赋值给当前层级数,这样的话，才可以第三层级移动
        this.maxLevel = node.level;
      }
    },
    // 书写箭头函数@click="() => append(data)对应的方法
    append(data) {
      console.log("append", data);
      this.dialogType = "add"; //对话框变成添加类型
      this.title = "添加分类";
      //打开对话框，添加元素
      this.dialogVisible = true;
      this.category.parentCid = data.catId;
      // 新增的层级= 当前层级（字符串）*1 + 1
      this.category.catLevel = data.catLevel * 1 + 1;
      //清空表格中回显的值
      this.category.catId = null; //不带id的添加，id自增
      this.category.name = "";
      this.category.icon = "";
      this.category.productUnit = "";
      this.category.sort = 0;
      this.category.showStatus = 1;
    },
    //data:当前节点的数据
    edit(data) {
      console.log("edit", data);
      this.dialogType = "edit"; //对话框变成修改类型
      this.title = "修改分类";
      //用于点击edit标签进行回显操作
      this.dialogVisible = true;

      /*
        1、当其他人使用同一个系统，已经修改了数据，而我使用的还是10分钟
        前刷新出来的数据。正确回显方式应该是发送请求获取当前节点最新的数据，
        之后我们再进行修改。
         this.category.name = data.name;
        //catId用于后端进行更新操作
        this.category.catId = data.catId;
        2、${data.catId}动态获取id信息
      */
      this.$http({
        url: this.$http.adornUrl(`/product/category/info/${data.catId}`),
        method: "get",
      }).then(({ data }) => {
        //请求成功之后，将服务器中的数据进行回显。
        console.log("要回显的数据", data);
        this.category.catId = data.data.catId;
        this.category.name = data.data.name;
        this.category.icon = data.data.icon;
        this.category.productUnit = data.data.productUnit;
        this.category.parentCid = data.data.parentCid;
      });
    },

    remove(node, data) {
      console.log("remove", node, data);
      var ids = [data.catId];
      //删除数据之前，首先弹框提示( ${data.name} 外面有一个飘号)
      this.$confirm(`是否删除【 ${data.name} 】菜单?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          //发送请求
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(ids, false),
          }).then(({ data }) => {
            //删除成功，消息提示
            this.$message({
              message: "菜单删除成功",
              type: "success",
            });
            // 删除成功之后，重新刷新出菜单
            this.getMenus();
            //设置需要默认展开的菜单,赋值为删除节点的父节点id
            this.expandedKey = [node.parent.data.catId];
          });
        })
        .catch(() => {
          this.$message({
            type: "info",
            message: "已取消删除",
          });
        });
    },

    //判断对话框的操作是添加请求还是修改请求
    submitData() {
      if (this.dialogType == "add") {
        this.addCategory();
      }
      if (this.dialogType == "edit") {
        this.editCategory();
      }
    },
    //修改三级分类
    editCategory() {
      // 将要发送给前端的数据解构出来，不是全部发送
      var { catId, name, icon, productUnit } = this.category;
      var data = {
        catId: catId,
        name: name,
        icon: icon,
        productUnit: productUnit,
      };
      this.$http({
        url: this.$http.adornUrl("/product/category/update"),
        method: "post",
        data: this.$http.adornData(data, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单修改成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
    //添加三级分类的方法
    //this.category 是已经构造好的数据对象
    addCategory() {
      console.log("向服务器提交的三级分类数据", this.category);
      this.$http({
        url: this.$http.adornUrl("/product/category/save"),
        method: "post",
        data: this.$http.adornData(this.category, false),
      }).then(({ data }) => {
        this.$message({
          message: "菜单保存成功",
          type: "success",
        });
        //关闭对话框
        this.dialogVisible = false;
        //刷新菜单
        this.getMenus();
        //打开添加的要展开的菜单
        this.expandedKey = [this.category.parentCid];
      });
    },
  },

  //生命周期-创建完成（可以访问当前的this实例）
  created() {
    this.getMenus();
  },
};
```

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111231035848.png" alt="image-20210111231035848" style="zoom:67%;" />

最大的改动是将pCid变成了数据，使用下面的方式保存pCid，从而用于后来保存后的前端树型结构回显。

```vue
// 全局pCid,为了批量保存后能够展开
this.pCid.push(pCid);
```

### 3、批量删除

1、前端代码

```vue
<template>
  <div>
    <!--添加拖拽开关-->
    <el-switch
      v-model="draggable"
      active-text="开启拖拽"
      inactive-text="关闭拖拽"
    >
    </el-switch>
    <!--  
      v-if="draggable"(true)表示可以拖拽，按钮就会显示
    -->
    <el-button v-if="draggable" @click="batchSave">批量保存</el-button>
    <el-button type="danger" @click="batchDelete">批量删除</el-button>
    <!--添加树形结构
  :default-expanded-keys="expandedkeys" 动态绑定一个数据(前头有一个冒号数据)
  :expand-on-click-node="false" 设置节点点击时不展开
  draggable 开启拖拽效果
  allow-drop 拖拽时判定目标节点能否被放置
  @node-drop="handleDrop" 表示拖拽成功对应的事件
  ref="menuTree" 和批量删除按钮一起使用，找到<el-tree></el-tree>中被选中的节点
  -->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
      ref="menuTree"
    >
      <!-- 插槽形式，解构写法，node当前节点，data节点数据 -->
      <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <!-- 添加两个按钮 -->
          <el-button
            v-if="node.level <= 2"
            type="text"
            size="mini"
            @click="() => append(data)"
          >
            Append
          </el-button>
          <el-button type="text" size="mini" @click="() => edit(data)">
            Edit
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)"
          >
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!-- 添加一个对话框 
    :close-on-click-modal="false"表示通过点击 modal（弹出对话框的叉号） 来关闭 Dialog
    -->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
    >
      <!-- dialog中添加一个嵌套表单 -->
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>
        <el-form-item label="计量单位">
          <el-input
            v-model="category.productUnit"
            autocomplete="off"
          ></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="submitData">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

methods: {
  //批量删除
    batchDelete() {
      let catIds = [];
      //选中不只是叶子节点和不包含半选节点的被选中节点。返回一个数组
      let checkedNodes = this.$refs.menuTree.getCheckedNodes();
      console.log("被选中的元素", checkedNodes);
      for (let i = 0; i < checkedNodes.length; i++) {
        catIds.push(checkedNodes[i].catId);
      }
      //删除数据之前先确认
      this.$confirm(`是否批量删除catId为【 ${catIds} 】节点?`, "提示", {
        confirmButtonText: "确定",
        cancelButtonText: "取消",
        type: "warning",
      })
        .then(() => {
          this.$http({
            url: this.$http.adornUrl("/product/category/delete"),
            method: "post",
            data: this.$http.adornData(catIds, false),
          }).then(({ data }) => {
            this.$message({
              message: "批量删除成功",
              type: "success",
            });
            this.getMenus();
          });
        })
        .catch(() => {});
    }
}
```

界面显示：

<img src="https://gitee.com/whlgdxlkl/my-picture-bed/raw/master/uploadPicture/image-20210111233303005.png" alt="image-20210111233303005" style="zoom:67%;" />

# 4、总结

前后端交互流程：

前端负责收集数据，组装好各种数据，但是真正的增删改查执行功能发送给后台，后台将前端收集来的数据转换成自己想要的数据后，再调用service来处理真正的功能。

使用最多的是http的post请求，该请求将数据转化为json，后端使用@RequestBody注解来取出请求体的参数，将其再转化为指定的对象。

理想情况下，只需要编写后台的请求处理功能和与前端进行联调的接口。编写好接口后，需要有前端完善界面效果，然后将真正的请求给我们后台发送请求。